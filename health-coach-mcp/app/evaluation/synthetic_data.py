"""
Synthetic data generators for Health Coach evaluation
"""
import random
from typing import Any, Dict, List, Optional, Tuple
from datetime import datetime, timedelta
from dataclasses import dataclass
import json
import uuid

from app.core.hierarchy import (
    Cohort, IntentClass, Category, SubIntent, 
    CONSTRAINT_HIERARCHY, get_applicable_constraints
)


@dataclass
class SyntheticUser:
    """Synthetic user profile for testing"""
    user_id: str
    cohort: Cohort
    demographics: Dict[str, Any]
    preferences: Dict[str, Any]
    health_goals: List[str]
    constraints: List[str]
    created_at: datetime


@dataclass
class SyntheticQuery:
    """Synthetic query for testing"""
    query_id: str
    text: str
    expected_category: Category
    expected_intent: IntentClass
    expected_sub_intent: Optional[str]
    user_cohort: Cohort
    context: Dict[str, Any]
    difficulty_level: str  # easy, medium, hard
    query_type: str  # in_scope, out_of_scope, ambiguous, edge_case


@dataclass
class SyntheticBelief:
    """Synthetic belief for testing"""
    belief_id: str
    content: str
    type: str
    category: Category
    confidence: float
    created_at: datetime
    user_id: str


@dataclass
class SyntheticHealthData:
    """Synthetic health data for testing"""
    data_id: str
    user_id: str
    biomarker_type: str
    value: float
    unit: str
    timestamp: datetime
    category: Category


class SyntheticDataGenerator:
    """Generator for creating synthetic test data"""
    
    def __init__(self, seed: Optional[int] = None):
        if seed is not None:
            random.seed(seed)
        
        self.user_templates = self._load_user_templates()
        self.query_templates = self._load_query_templates()
        self.belief_templates = self._load_belief_templates()
        self.health_data_templates = self._load_health_data_templates()
    
    def generate_users(self, count: int = 50) -> List[SyntheticUser]:
        """Generate synthetic users across all cohorts"""
        users = []
        cohorts = list(Cohort)
        
        for i in range(count):
            cohort = random.choice(cohorts)
            user = self._generate_user(cohort, i)
            users.append(user)
        
        return users
    
    def generate_queries(
        self, 
        count: int = 200,
        distribution: Optional[Dict[str, float]] = None
    ) -> List[SyntheticQuery]:
        """Generate synthetic queries with specified distribution"""
        if distribution is None:
            distribution = {
                \"in_scope\": 0.7,\n                \"out_of_scope\": 0.15,\n                \"ambiguous\": 0.1,\n                \"edge_case\": 0.05\n            }\n        \n        queries = []\n        cohorts = list(Cohort)\n        categories = list(Category)\n        intents = list(IntentClass)\n        \n        for i in range(count):\n            query_type = self._weighted_choice(distribution)\n            cohort = random.choice(cohorts)\n            \n            if query_type == \"in_scope\":\n                category = random.choice(categories)\n                intent = random.choice(intents)\n                query = self._generate_in_scope_query(cohort, category, intent, i)\n            elif query_type == \"out_of_scope\":\n                query = self._generate_out_of_scope_query(cohort, i)\n            elif query_type == \"ambiguous\":\n                query = self._generate_ambiguous_query(cohort, i)\n            else:  # edge_case\n                query = self._generate_edge_case_query(cohort, i)\n            \n            queries.append(query)\n        \n        return queries\n    \n    def generate_beliefs(self, user_ids: List[str], count_per_user: int = 10) -> List[SyntheticBelief]:\n        \"\"\"Generate synthetic beliefs for users\"\"\"\n        beliefs = []\n        categories = list(Category)\n        \n        for user_id in user_ids:\n            for i in range(count_per_user):\n                category = random.choice(categories)\n                belief = self._generate_belief(user_id, category, i)\n                beliefs.append(belief)\n        \n        return beliefs\n    \n    def generate_health_data(\n        self, \n        user_ids: List[str], \n        days_back: int = 30,\n        entries_per_day: int = 5\n    ) -> List[SyntheticHealthData]:\n        \"\"\"Generate synthetic health data for users\"\"\"\n        health_data = []\n        categories = list(Category)\n        \n        for user_id in user_ids:\n            for day_offset in range(days_back):\n                date = datetime.now() - timedelta(days=day_offset)\n                \n                for i in range(entries_per_day):\n                    category = random.choice(categories)\n                    data_point = self._generate_health_data_point(user_id, category, date, i)\n                    health_data.append(data_point)\n        \n        return health_data\n    \n    def generate_conversation_history(\n        self, \n        user_id: str, \n        session_count: int = 5,\n        messages_per_session: int = 10\n    ) -> List[Dict[str, Any]]:\n        \"\"\"Generate synthetic conversation history\"\"\"\n        conversations = []\n        \n        for session_i in range(session_count):\n            session_id = f\"session_{user_id}_{session_i}\"\n            session_date = datetime.now() - timedelta(days=random.randint(1, 30))\n            \n            messages = []\n            for msg_i in range(messages_per_session):\n                if msg_i % 2 == 0:  # User message\n                    message = {\n                        \"role\": \"user\",\n                        \"content\": self._generate_user_message(),\n                        \"timestamp\": (session_date + timedelta(minutes=msg_i * 2)).isoformat()\n                    }\n                else:  # Assistant message\n                    message = {\n                        \"role\": \"assistant\",\n                        \"content\": self._generate_assistant_message(),\n                        \"timestamp\": (session_date + timedelta(minutes=msg_i * 2 + 1)).isoformat()\n                    }\n                messages.append(message)\n            \n            conversation = {\n                \"session_id\": session_id,\n                \"user_id\": user_id,\n                \"messages\": messages,\n                \"created_at\": session_date.isoformat()\n            }\n            conversations.append(conversation)\n        \n        return conversations\n    \n    def _generate_user(self, cohort: Cohort, index: int) -> SyntheticUser:\n        \"\"\"Generate a single synthetic user\"\"\"\n        template = self.user_templates[cohort.value]\n        \n        # Generate demographics\n        demographics = {\n            \"age\": random.randint(template[\"age_range\"][0], template[\"age_range\"][1]),\n            \"gender\": random.choice(template[\"genders\"]),\n            \"location\": random.choice(template[\"locations\"]),\n            \"occupation\": random.choice(template[\"occupations\"])\n        }\n        \n        # Generate preferences\n        preferences = {\n            \"workout_time\": random.choice(template[\"workout_times\"]),\n            \"diet_style\": random.choice(template[\"diet_styles\"]),\n            \"tracking_level\": random.choice(template[\"tracking_levels\"]),\n            \"communication_style\": random.choice(template[\"communication_styles\"])\n        }\n        \n        # Generate health goals\n        goal_count = random.randint(2, 4)\n        health_goals = random.sample(template[\"health_goals\"], goal_count)\n        \n        # Generate constraints\n        constraint_count = random.randint(1, 3)\n        constraints = random.sample(template[\"constraints\"], constraint_count)\n        \n        return SyntheticUser(\n            user_id=f\"user_{cohort.value}_{index:03d}\",\n            cohort=cohort,\n            demographics=demographics,\n            preferences=preferences,\n            health_goals=health_goals,\n            constraints=constraints,\n            created_at=datetime.now() - timedelta(days=random.randint(1, 90))\n        )\n    \n    def _generate_in_scope_query(\n        self, \n        cohort: Cohort, \n        category: Category, \n        intent: IntentClass, \n        index: int\n    ) -> SyntheticQuery:\n        \"\"\"Generate an in-scope query\"\"\"\n        # Get sub-intents for this category and intent\n        matching_sub_intents = []\n        for sub_intent_id, sub_intent in CONSTRAINT_HIERARCHY[\"sub_intents\"].items():\n            if (sub_intent.parent_category == category and \n                sub_intent.parent_intent == intent):\n                matching_sub_intents.append((sub_intent_id, sub_intent))\n        \n        # Select a sub-intent and example query\n        if matching_sub_intents:\n            sub_intent_id, sub_intent = random.choice(matching_sub_intents)\n            base_query = random.choice(sub_intent.example_queries)\n            \n            # Add cohort-specific variation\n            query_text = self._vary_query_for_cohort(base_query, cohort)\n            \n            return SyntheticQuery(\n                query_id=f\"query_in_scope_{index:04d}\",\n                text=query_text,\n                expected_category=category,\n                expected_intent=intent,\n                expected_sub_intent=sub_intent_id,\n                user_cohort=cohort,\n                context={\"sub_intent_name\": sub_intent.name},\n                difficulty_level=self._assess_query_difficulty(query_text, cohort),\n                query_type=\"in_scope\"\n            )\n        else:\n            # Fallback to general query\n            query_text = self._generate_general_query(category, intent, cohort)\n            return SyntheticQuery(\n                query_id=f\"query_in_scope_{index:04d}\",\n                text=query_text,\n                expected_category=category,\n                expected_intent=intent,\n                expected_sub_intent=None,\n                user_cohort=cohort,\n                context={},\n                difficulty_level=\"medium\",\n                query_type=\"in_scope\"\n            )\n    \n    def _generate_out_of_scope_query(self, cohort: Cohort, index: int) -> SyntheticQuery:\n        \"\"\"Generate an out-of-scope query\"\"\"\n        out_of_scope_queries = [\n            \"What's the weather like today?\",\n            \"Can you help me with my math homework?\",\n            \"What's the capital of France?\",\n            \"How do I fix my car?\",\n            \"What should I watch on Netflix?\",\n            \"Can you write code for me?\",\n            \"What's the stock price of Apple?\",\n            \"How do I learn Spanish?\",\n            \"What's the best restaurant nearby?\",\n            \"Can you book a flight for me?\"\n        ]\n        \n        query_text = random.choice(out_of_scope_queries)\n        \n        return SyntheticQuery(\n            query_id=f\"query_out_of_scope_{index:04d}\",\n            text=query_text,\n            expected_category=None,  # Should not be categorized\n            expected_intent=None,\n            expected_sub_intent=None,\n            user_cohort=cohort,\n            context={\"expected_response\": \"out_of_scope\"},\n            difficulty_level=\"easy\",\n            query_type=\"out_of_scope\"\n        )\n    \n    def _generate_ambiguous_query(self, cohort: Cohort, index: int) -> SyntheticQuery:\n        \"\"\"Generate an ambiguous query that could fit multiple categories\"\"\"\n        ambiguous_queries = [\n            \"I need more energy\",  # Could be nutrition, sleep, or exercise\n            \"How can I feel better?\",  # Could be any category\n            \"I'm tired all the time\",  # Could be sleep or nutrition\n            \"I want to be healthier\",  # Very general\n            \"Something's not working\",  # Vague\n            \"I need help with my routine\",  # Could be any category\n            \"How do I optimize my performance?\",  # Could be exercise or nutrition\n            \"I want to lose weight\",  # Could be nutrition or exercise\n            \"How can I recover better?\",  # Could be sleep or exercise\n            \"I need motivation\"  # Could be any category\n        ]\n        \n        query_text = random.choice(ambiguous_queries)\n        \n        # For ambiguous queries, we might expect clarification\n        return SyntheticQuery(\n            query_id=f\"query_ambiguous_{index:04d}\",\n            text=query_text,\n            expected_category=None,  # Should require clarification\n            expected_intent=None,\n            expected_sub_intent=None,\n            user_cohort=cohort,\n            context={\"expected_response\": \"clarification_needed\"},\n            difficulty_level=\"hard\",\n            query_type=\"ambiguous\"\n        )\n    \n    def _generate_edge_case_query(self, cohort: Cohort, index: int) -> SyntheticQuery:\n        \"\"\"Generate edge case queries\"\"\"\n        edge_cases = [\n            \"\",  # Empty query\n            \"a\",  # Too short\n            \"help\" * 100,  # Too repetitive\n            \"!@#$%^&*()\",  # Special characters only\n            \"123456789\",  # Numbers only\n            \"HELP ME NOW!!!\",  # All caps with excessive punctuation\n            \"i need help with my sleep nutrition exercise routine all at once\",  # Too broad\n            \"Can you help me design a 47-week periodized hypertrophy protocol with biweekly deloads and autoregulated RPE progression while accounting for my lactose intolerance and shift work schedule?\",  # Too specific/complex\n        ]\n        \n        query_text = random.choice(edge_cases)\n        \n        return SyntheticQuery(\n            query_id=f\"query_edge_case_{index:04d}\",\n            text=query_text,\n            expected_category=None,\n            expected_intent=None,\n            expected_sub_intent=None,\n            user_cohort=cohort,\n            context={\"expected_response\": \"error_handling\"},\n            difficulty_level=\"hard\",\n            query_type=\"edge_case\"\n        )\n    \n    def _generate_belief(self, user_id: str, category: Category, index: int) -> SyntheticBelief:\n        \"\"\"Generate a synthetic belief\"\"\"\n        template = self.belief_templates[category.value]\n        belief_content = random.choice(template[\"contents\"])\n        belief_type = random.choice(template[\"types\"])\n        confidence = random.uniform(0.3, 0.9)\n        \n        return SyntheticBelief(\n            belief_id=f\"belief_{category.value}_{user_id}_{index:03d}\",\n            content=belief_content,\n            type=belief_type,\n            category=category,\n            confidence=confidence,\n            created_at=datetime.now() - timedelta(days=random.randint(1, 30)),\n            user_id=user_id\n        )\n    \n    def _generate_health_data_point(\n        self, \n        user_id: str, \n        category: Category, \n        date: datetime, \n        index: int\n    ) -> SyntheticHealthData:\n        \"\"\"Generate a synthetic health data point\"\"\"\n        template = self.health_data_templates[category.value]\n        biomarker = random.choice(list(template.keys()))\n        biomarker_info = template[biomarker]\n        \n        # Generate realistic value within range\n        value = random.uniform(biomarker_info[\"min\"], biomarker_info[\"max\"])\n        if biomarker_info.get(\"integer\", False):\n            value = int(value)\n        \n        return SyntheticHealthData(\n            data_id=f\"health_{category.value}_{user_id}_{date.strftime('%Y%m%d')}_{index}\",\n            user_id=user_id,\n            biomarker_type=biomarker,\n            value=value,\n            unit=biomarker_info[\"unit\"],\n            timestamp=date + timedelta(hours=random.randint(6, 22)),\n            category=category\n        )\n    \n    def _vary_query_for_cohort(self, base_query: str, cohort: Cohort) -> str:\n        \"\"\"Add cohort-specific variations to queries\"\"\"\n        if cohort == Cohort.SEDENTARY_BEGINNER:\n            # Simpler language, more basic questions\n            variations = {\n                \"training\": \"exercise\",\n                \"protocol\": \"routine\",\n                \"optimize\": \"improve\",\n                \"periodization\": \"planning\"\n            }\n        elif cohort == Cohort.BIOHACKER:\n            # More technical language\n            variations = {\n                \"exercise\": \"training protocol\",\n                \"improve\": \"optimize\",\n                \"routine\": \"periodized program\",\n                \"better\": \"enhanced performance\"\n            }\n        else:\n            return base_query\n        \n        varied_query = base_query\n        for old, new in variations.items():\n            varied_query = varied_query.replace(old, new)\n        \n        return varied_query\n    \n    def _assess_query_difficulty(self, query: str, cohort: Cohort) -> str:\n        \"\"\"Assess the difficulty level of a query\"\"\"\n        # Simple heuristics\n        word_count = len(query.split())\n        has_technical_terms = any(term in query.lower() for term in \n                                 [\"periodization\", \"autoregulation\", \"periodized\", \"macros\", \"rpg\"])\n        \n        if word_count < 5:\n            return \"easy\"\n        elif word_count > 15 or has_technical_terms:\n            return \"hard\"\n        else:\n            return \"medium\"\n    \n    def _generate_general_query(self, category: Category, intent: IntentClass, cohort: Cohort) -> str:\n        \"\"\"Generate a general query for category and intent\"\"\"\n        templates = {\n            (Category.EXERCISE, IntentClass.PLAN): \"Help me create a workout plan\",\n            (Category.EXERCISE, IntentClass.TASK): \"Set up workout reminders\",\n            (Category.EXERCISE, IntentClass.EVIDENCE_RESEARCH): \"Show me research on exercise\",\n            (Category.NUTRITION, IntentClass.PLAN): \"Help me plan my meals\",\n            (Category.NUTRITION, IntentClass.TASK): \"Track my nutrition\",\n            (Category.SLEEP, IntentClass.PLAN): \"Help me improve my sleep\",\n        }\n        \n        return templates.get((category, intent), f\"Help me with {category.value}\")\n    \n    def _generate_user_message(self) -> str:\n        \"\"\"Generate a realistic user message\"\"\"\n        messages = [\n            \"How's my progress looking?\",\n            \"I had a great workout today\",\n            \"I'm struggling with consistency\",\n            \"Can we adjust my plan?\",\n            \"I didn't sleep well last night\",\n            \"I ate off-plan yesterday\",\n            \"I'm feeling motivated today\",\n            \"I have a question about my routine\"\n        ]\n        return random.choice(messages)\n    \n    def _generate_assistant_message(self) -> str:\n        \"\"\"Generate a realistic assistant message\"\"\"\n        messages = [\n            \"Great job on staying consistent! Let's review your progress.\",\n            \"I understand that can be challenging. Let's work on some strategies.\",\n            \"Based on your data, I can see some positive trends.\",\n            \"That's a great question! Let me help you with that.\",\n            \"Sleep is crucial for recovery. Let's look at your sleep patterns.\",\n            \"It happens to everyone. What matters is getting back on track.\",\n            \"I'm glad to hear you're feeling motivated! Let's use that energy.\",\n            \"Absolutely! Let me provide some guidance on that.\"\n        ]\n        return random.choice(messages)\n    \n    def _weighted_choice(self, weights: Dict[str, float]) -> str:\n        \"\"\"Make a weighted random choice\"\"\"\n        items = list(weights.keys())\n        weights_list = list(weights.values())\n        return random.choices(items, weights=weights_list)[0]\n    \n    def _load_user_templates(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Load user generation templates\"\"\"\n        return {\n            \"sedentary_beginner\": {\n                \"age_range\": [25, 45],\n                \"genders\": [\"male\", \"female\", \"non-binary\"],\n                \"locations\": [\"urban\", \"suburban\", \"rural\"],\n                \"occupations\": [\"office worker\", \"teacher\", \"student\", \"retail\"],\n                \"workout_times\": [\"morning\", \"evening\", \"flexible\"],\n                \"diet_styles\": [\"standard\", \"trying to eat healthier\", \"no restrictions\"],\n                \"tracking_levels\": [\"minimal\", \"basic\", \"occasional\"],\n                \"communication_styles\": [\"simple\", \"encouraging\", \"patient\"],\n                \"health_goals\": [\"lose weight\", \"get stronger\", \"feel better\", \"build habits\", \"more energy\"],\n                \"constraints\": [\"limited time\", \"home workouts only\", \"budget conscious\", \"beginner friendly\"]\n            },\n            \"health_enthusiast\": {\n                \"age_range\": [28, 50],\n                \"genders\": [\"male\", \"female\", \"non-binary\"],\n                \"locations\": [\"urban\", \"suburban\"],\n                \"occupations\": [\"professional\", \"manager\", \"healthcare\", \"fitness instructor\"],\n                \"workout_times\": [\"morning\", \"lunch break\", \"evening\"],\n                \"diet_styles\": [\"balanced\", \"Mediterranean\", \"flexible dieting\", \"whole foods\"],\n                \"tracking_levels\": [\"regular\", \"detailed\", \"consistent\"],\n                \"communication_styles\": [\"informative\", \"motivational\", \"practical\"],\n                \"health_goals\": [\"improve performance\", \"maintain health\", \"body composition\", \"stress management\"],\n                \"constraints\": [\"busy schedule\", \"travel frequently\", \"family commitments\"]\n            },\n            \"optimizer\": {\n                \"age_range\": [25, 55],\n                \"genders\": [\"male\", \"female\", \"non-binary\"],\n                \"locations\": [\"urban\", \"suburban\"],\n                \"occupations\": [\"engineer\", \"executive\", \"entrepreneur\", \"scientist\"],\n                \"workout_times\": [\"early morning\", \"planned sessions\", \"structured\"],\n                \"diet_styles\": [\"macro tracking\", \"intermittent fasting\", \"optimized nutrition\"],\n                \"tracking_levels\": [\"comprehensive\", \"data-driven\", \"metrics-focused\"],\n                \"communication_styles\": [\"analytical\", \"detailed\", \"evidence-based\"],\n                \"health_goals\": [\"performance optimization\", \"longevity\", \"biomarker improvement\", \"efficiency\"],\n                \"constraints\": [\"high performance demands\", \"precise scheduling\", \"outcome focused\"]\n            },\n            \"biohacker\": {\n                \"age_range\": [25, 60],\n                \"genders\": [\"male\", \"female\", \"non-binary\"],\n                \"locations\": [\"urban\", \"tech hubs\"],\n                \"occupations\": [\"tech executive\", \"researcher\", \"entrepreneur\", \"biohacker\"],\n                \"workout_times\": [\"optimized timing\", \"circadian aligned\", \"data-driven\"],\n                \"diet_styles\": [\"ketogenic\", \"personalized nutrition\", \"experimental protocols\"],\n                \"tracking_levels\": [\"continuous monitoring\", \"multi-metric\", \"experimental\"],\n                \"communication_styles\": [\"technical\", \"cutting-edge\", \"experimental\"],\n                \"health_goals\": [\"longevity optimization\", \"cognitive enhancement\", \"performance maximization\"],\n                \"constraints\": [\"access to advanced tools\", \"experimental mindset\", \"high investment\"]\n            }\n        }\n    \n    def _load_query_templates(self) -> Dict[str, List[str]]:\n        \"\"\"Load query generation templates\"\"\"\n        return {\n            \"exercise_plan\": [\n                \"Help me design a workout program\",\n                \"Create a training plan for {goal}\",\n                \"I need a {frequency} workout routine\",\n                \"Design a program for {equipment}\"\n            ],\n            \"nutrition_plan\": [\n                \"Help me plan my meals\",\n                \"Create a diet for {goal}\",\n                \"I need meal prep ideas\",\n                \"Design a nutrition plan\"\n            ],\n            \"sleep_optimization\": [\n                \"Help me sleep better\",\n                \"Optimize my sleep schedule\",\n                \"I need a bedtime routine\",\n                \"Improve my sleep quality\"\n            ]\n        }\n    \n    def _load_belief_templates(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Load belief generation templates\"\"\"\n        return {\n            \"exercise\": {\n                \"contents\": [\n                    \"High-intensity workouts are most effective\",\n                    \"Consistency is more important than intensity\",\n                    \"Compound movements are superior to isolation\",\n                    \"Cardio is necessary for fat loss\",\n                    \"Strength training is essential for health\"\n                ],\n                \"types\": [\"preference\", \"scientific\", \"experiential\", \"cultural\"]\n            },\n            \"nutrition\": {\n                \"contents\": [\n                    \"Protein is the most important macronutrient\",\n                    \"Meal timing affects metabolism\",\n                    \"Processed foods should be avoided\",\n                    \"Supplements are necessary for optimal health\",\n                    \"Calorie counting is essential for weight management\"\n                ],\n                \"types\": [\"dietary\", \"scientific\", \"cultural\", \"personal\"]\n            },\n            \"sleep\": {\n                \"contents\": [\n                    \"8 hours of sleep is optimal for everyone\",\n                    \"Sleep quality is more important than quantity\",\n                    \"Blue light significantly impacts sleep\",\n                    \"Napping improves cognitive performance\",\n                    \"Sleep tracking improves sleep quality\"\n                ],\n                \"types\": [\"scientific\", \"experiential\", \"cultural\", \"technological\"]\n            }\n        }\n    \n    def _load_health_data_templates(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Load health data generation templates\"\"\"\n        return {\n            \"exercise\": {\n                \"steps\": {\"min\": 2000, \"max\": 20000, \"unit\": \"steps\", \"integer\": True},\n                \"active_minutes\": {\"min\": 10, \"max\": 120, \"unit\": \"minutes\", \"integer\": True},\n                \"vo2_max\": {\"min\": 30, \"max\": 70, \"unit\": \"ml/kg/min\"},\n                \"heart_rate\": {\"min\": 50, \"max\": 100, \"unit\": \"bpm\", \"integer\": True}\n            },\n            \"nutrition\": {\n                \"glucose\": {\"min\": 70, \"max\": 140, \"unit\": \"mg/dL\", \"integer\": True},\n                \"weight\": {\"min\": 120, \"max\": 300, \"unit\": \"lbs\"},\n                \"body_fat\": {\"min\": 8, \"max\": 35, \"unit\": \"%\"},\n                \"calories\": {\"min\": 1200, \"max\": 4000, \"unit\": \"kcal\", \"integer\": True}\n            },\n            \"sleep\": {\n                \"sleep_duration\": {\"min\": 4, \"max\": 12, \"unit\": \"hours\"},\n                \"sleep_quality\": {\"min\": 1, \"max\": 10, \"unit\": \"score\", \"integer\": True},\n                \"hrv\": {\"min\": 20, \"max\": 100, \"unit\": \"ms\"},\n                \"resting_hr\": {\"min\": 45, \"max\": 85, \"unit\": \"bpm\", \"integer\": True}\n            }\n        }"